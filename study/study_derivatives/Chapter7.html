<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Hyeonghwan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Hyeonghwan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../home.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../home_study.html"> 
<span class="menu-text">Study</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../home_life.html"> 
<span class="menu-text">Life</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
    <a href="https://github.com/kimhyeonghwan" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
    <div class="dropdown">
      <a href="" title="" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label=""><i class="bi bi-google"></i></a>
      <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="">
            gudghks93@gmail.com
            </a>
          </li>
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="mailto:gudghks93@gmail.com">
            Send E-mail
            </a>
          </li>
      </ul>
    </div>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#chapter-7" id="toc-chapter-7" class="nav-link active" data-scroll-target="#chapter-7">Chapter 7</a>
  <ul class="collapse">
  <li><a href="#mechanics-of-interest-rate-swaps" id="toc-mechanics-of-interest-rate-swaps" class="nav-link" data-scroll-target="#mechanics-of-interest-rate-swaps">7.1 Mechanics of interest rate swaps</a></li>
  <li><a href="#determining-risk-free-rates" id="toc-determining-risk-free-rates" class="nav-link" data-scroll-target="#determining-risk-free-rates">7.2 Determining Risk-Free rates</a></li>
  <li><a href="#reasons-for-trading-interest-rate-swaps" id="toc-reasons-for-trading-interest-rate-swaps" class="nav-link" data-scroll-target="#reasons-for-trading-interest-rate-swaps">7.3~5 Reasons for trading Interest Rate Swaps</a></li>
  <li><a href="#valuation-of-interest-rate-swaps" id="toc-valuation-of-interest-rate-swaps" class="nav-link" data-scroll-target="#valuation-of-interest-rate-swaps">7.6~7 Valuation of Interest Rate Swaps</a></li>
  <li><a href="#fixed-for-fixed-currency-swaps" id="toc-fixed-for-fixed-currency-swaps" class="nav-link" data-scroll-target="#fixed-for-fixed-currency-swaps">7.8 Fixed-For-Fixed Currency Swaps</a></li>
  <li><a href="#valuation-of-fixed-for-fixed-currency-swaps" id="toc-valuation-of-fixed-for-fixed-currency-swaps" class="nav-link" data-scroll-target="#valuation-of-fixed-for-fixed-currency-swaps">7.9~10 Valuation of Fixed-For-Fixed Currency Swaps</a></li>
  <li><a href="#other-types-of-swaps" id="toc-other-types-of-swaps" class="nav-link" data-scroll-target="#other-types-of-swaps">7.11~13 Other Types of Swaps</a>
  <ul class="collapse">
  <li><a href="#cds-credit-default-swaps" id="toc-cds-credit-default-swaps" class="nav-link" data-scroll-target="#cds-credit-default-swaps">CDS, Credit Default Swaps</a></li>
  <li><a href="#other-interest-rate-swaps" id="toc-other-interest-rate-swaps" class="nav-link" data-scroll-target="#other-interest-rate-swaps">Other Interest Rate Swaps</a></li>
  <li><a href="#quantos" id="toc-quantos" class="nav-link" data-scroll-target="#quantos">Quantos</a></li>
  <li><a href="#equity-swaps" id="toc-equity-swaps" class="nav-link" data-scroll-target="#equity-swaps">Equity Swaps</a></li>
  <li><a href="#options" id="toc-options" class="nav-link" data-scroll-target="#options">Options</a></li>
  <li><a href="#other-swaps" id="toc-other-swaps" class="nav-link" data-scroll-target="#other-swaps">Other Swaps</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="chapter-7" class="level1 unnumbered">
<h1 class="unnumbered">Chapter 7</h1>
<p>스왑, Swaps</p>
<p>최초의 스왑은 1981년 IBM과 World Bank간에 체결된 통화스왑입니다. 당시 World Bank는 독일과 스위스 통화를 직접적으로 대차할 수 없었고 IBM에게 미국달러에 대한 이자를 지급하고 독일 및 스위스 통화에 대한 이자를 수취하는 계약을 체결하였습니다.</p>
<p>스왑은 일정 주기마다 이자를 주고 받는 계약으로, 이자율선도 및 통화선도계약을 연속적으로 체결하는 것과 동일한 메커니즘을 가지고 있습니다.</p>
<section id="mechanics-of-interest-rate-swaps" class="level2">
<h2 class="anchored" data-anchor-id="mechanics-of-interest-rate-swaps">7.1 Mechanics of interest rate swaps</h2>
<p><strong>이자율 스왑</strong>은 계약 당사자들끼리 <strong>미래 특정시점</strong>까지 <strong>일정 주기</strong>마다 정해둔 명목금액에 대하여 <strong>정해둔 고정금리와 변동금리를 적용한 이자를 주고 받는 계약</strong>입니다.</p>
<p>여기에 적용되는 변동금리는 최근까지 LIBOR가 널리 사용되었습니다. 그러나, LIBOR 조작 사태 이후 LIBOR 산출 중단에 따라 이를 대체하고자 하는 논의가 지속되고 있으며, 특히 과거에 체결되었던 20년 이상의 장기스왑의 경우 중도에 Reference float rate를 교체해야하므로, 미국의 경우 US LIBOR 대신 SOFR+<span class="math inline">\(\alpha\)</span>를 사용하는 추세입니다.</p>
<p>SOFR 및 영국의 SONIA 등 Overnight금리는 실제 거래기반의 담보부 금리로 LIBOR 대비 조작가능성이 낮고 안정성은 높으며, 선물을 통해 장기금리로 쉽게 치환할 수 있는 등의 장점이 있습니다. 최근에는 이러한 Overnight금리를 이용한 스왑이 널리 이용되고 있고, <strong>이자율스왑 중 Overnight금리를 이용한 스왑을 Overnight Indexed Swaps, OIS</strong>라 부릅니다.</p>
<div class="callout callout-style-default callout-note callout-titled" title="LIBOR swaps vs. OISs">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
LIBOR swaps vs.&nbsp;OISs
</div>
</div>
<div class="callout-body-container callout-body">
<p>두 스왑은 단순히 Reference float rate를 무엇을 사용하는지에 따라 구분되는 것이나, 두 금리의 이자율 산출방식의 차이가 있음을 유의하여야 합니다.</p>
<p>Libor는 Forward-looking금리로, 스왑계약으로 인해 3개월마다 고정금리와 Libor를 주고 받는다면, 향후 3개월간 적용될 3-month Libor가 현재시점에 결정됩니다. 반면에 Overnight금리는 Backward-looking금리로, 향후 3개월간 적용될 3-month rate는 향후 3개월간 Overnight금리를 누적하여 산출하게 되고, 즉 금리를 주고 받을 시점이 되서야 확정할 수 있게됩니다.</p>
</div>
</div>
</section>
<section id="determining-risk-free-rates" class="level2">
<h2 class="anchored" data-anchor-id="determining-risk-free-rates">7.2 Determining Risk-Free rates</h2>
<p>OISs는 무위험이자율을 결정하는 데에 매우 중요한 역할을 맡고 있습니다. 먼저, OIS 체결시 결정되는 고정금리인 OIS rate는 현재 스왑계약의 가치가 0이되는 지점에서 결정될 것 입니다.</p>
<p>여기서, 만약 스왑계약 만기시점에 명목금액을 상호간에 주고 받는다고 생각해봅시다. 동일한 원금을 계약당사자간 주고 받으므로 계약의 가치에는 변동이 없습니다.</p>
<p>이때, 변동금리를 받는 경우와 고정금리(OIS rate)를 받는 경우의 현금흐름을 각각 생각해보면, 고정금리를 받는 경우는 OIS rate를 쿠폰으로 지급하고 원금이 스왑계약의 명목금액인 채권과 동일하며, 변동금리를 받는 경우는 Overnight rate를 쿠폰으로 지급하고 원금이 명목금액인 변동금리채권과 동일합니다.</p>
<p>한편, Overnight rate를 할인율로 사용한다면 Overnight rate를 쿠폰으로 지급하는 변동금리채권의 현재가치는 원금(Par value)와 동일하게 됩니다. 이제, OIS rate는 현재 스왑계약의 가치가 0이되는 지점이라고 했으므로, 변동금리채권과 OIS rate를 쿠폰으로 지급하는 채권의 가치는 동일한 Par value에서 결정됩니다. 즉, <strong>OIS rate는 채권의 Par rate와 동일하게 됩니다.</strong></p>
<p><span class="math display">\[Par\;value=FRN's\;price=Value\;of\;float\;rate\;receiver=\]</span> <span class="math display">\[Value\;of\;OIS\;rate\;receiver=Treasury\;bond's\;price\]</span></p>
</section>
<section id="reasons-for-trading-interest-rate-swaps" class="level2">
<h2 class="anchored" data-anchor-id="reasons-for-trading-interest-rate-swaps">7.3~5 Reasons for trading Interest Rate Swaps</h2>
<p>스왑을 거래하는 이유는 크게 2가지입니다.</p>
<p>먼저, <strong>보유하고 있는 부채나 자산의 금리구조를 바꾸고 싶은 경우</strong>입니다. 내가 <strong>은행에서 변동금리로 자금을 빌렸다면,</strong> 자금의 만기와 이자지급시기가 유사한 <strong>스왑 매수계약</strong> 체결을 통해 고정금리를 지급하고 변동금리를 받음으로써 <strong>은행의 부채를 고정금리 부채로 변환하는 효과</strong>가 있습니다. 이러한 작업은 <strong>자산과 부채간 듀레이션을 일치</strong>시키고자 하는 기관 등에서 주로 사용합니다.</p>
<p>다음으로는 <strong>비교우위(Comparative advantage) 전략</strong>을 이용하기 위해서 입니다. 자금을 빌리고자 할 때, <strong>A기업은 변동금리보다 고정금리로 빌릴 때 상대적으로 비교우위</strong>가 있고 <strong>B기업은 변동금리로 빌릴 때 비교우위</strong>가 있다고 가정해봅시다. <strong>A기업이 변동금리로 자금을 빌려야 하는 경우</strong>, 바로 빌리는 것이 아니라 비교우위가 있는 <strong>고정금리로 먼저 자금을 차입</strong>하고, 변동금리에 우위가 있는 B기업과 <strong>스왑계약(A:매도/B:매수)</strong>한다면, <strong>이자비용을 절약</strong>하는 효과를 얻을 수 있습니다. 물론, 실제로는 기업에 따라 이러한 비교우위가 없을 수도 있고, 두 기업의 Default Risk가 비대칭적인 점을 고려하기 어려우며, 기업의 신용도에 따라 적용이자율이 미래에 변하기때문에 이러한 전략이 실행되기 어렵다는 비판도 존재합니다.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="The organization of swap trading">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The organization of swap trading
</div>
</div>
<div class="callout-body-container callout-body">
<p>스왑 매수는 고정금리 지급 및 변동금리 수취, 스왑 매도는 고정금리 수위 및 변동금리 지급을 의미합니다.</p>
<p>실제 시장에서는 매수/매도별로 호가가 나뉘는데, 일반적으로 이 매수/매도 호가의 평균값을 <em>Swap rate</em>라고 합니다.</p>
<p>또한, 국가 및 이자율마다 적용되는 Day count convention이 다를 수 있어 유의해야 합니다. 예를 들어 SOFR나 Libor는 <span class="math inline">\(\frac{actual}{360}\)</span>을 사용하지만, 고정금리의 경우 <span class="math inline">\(\frac{actual}{365}\)</span> 또는 <span class="math inline">\(\frac{30}{360}\)</span>을 주로 사용해야합니다.</p>
<p>2008년 금융위기 이후 스왑계약 및 미결제약정에 대한 위험관리를 강화하고자 하는 논의가 지속되고 있으며, 현재는 대부분 CCP에서 스왑 계약들을 한데 모아 청산결제를 수행하고, 국제스왑파생상품협회(International Swaps and Derivatives Association)에서 표준계약서를 제공하며 거래내역을 보고받고 있습니다.</p>
</div>
</div>
</section>
<section id="valuation-of-interest-rate-swaps" class="level2">
<h2 class="anchored" data-anchor-id="valuation-of-interest-rate-swaps">7.6~7 Valuation of Interest Rate Swaps</h2>
<p>스왑의 가치평가는, 현재시점에 스왑계약의 NPV가 “0”이 되는 고정금리가 스왑의 계약금리로 결정된다는 것에서 시작합니다.</p>
<p>즉, 이자율 선도계약과 매우 유사합니다. 실제로 스왑계약의 만기까지의 현금흐름을 매 이자교환시기마다 구분한다면, 각각의 이자교환은 하나의 이자율선도계약에 해당합니다. 따라서, 스왑계약의 가치평가는 다음 3단계로 이루어집니다.</p>
<ol type="1">
<li>먼저, 각 이자지급시기에 만기가 도래하는 동일한 변동금리 기반의 선도이자율을 모두 계산한다.</li>
<li>해당 선도이자율은 현재시점에 NPV가 “0”이므로 미래 이자지급시기에 지급할 예정인 변동금리와 선도이자율이 동일하다고 가정하고, 스왑의 미래현금흐름을 계산한다.</li>
<li>스왑의 현금흐름을 현재가치로 환산한다.(계약 시작시점이라면, 동일한 현금흐름을 가지는 고정금리(swap rate)를 산출한다.)</li>
</ol>
<p>즉, 스왑계약의 가치는 각 이자지급시기의 선도이자율과 무위험이자율만 알고있다면 구할 수 있습니다. 앞서 설명한대로, OIS를 통해 zero rate curve를 구할 수 있고, Forward rate도 계산할 수 있으므로, 스왑계약의 가치는 스왑의 현재 가격만으로 모두 평가할 수 있습니다.</p>
<div class="callout callout-style-default callout-important callout-titled" title="How the value changes through time">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
How the value changes through time
</div>
</div>
<div class="callout-body-container callout-body">
<p>스왑계약의 가치가 “0”이라는 의미는 이자지급시기별 현금흐름의 현재가치가 모두 “0”이라는 의미가 아닙니다. 대신, 모든 현금흐름의 현재가치를 더했을 때 0이 된다는 의미입니다.</p>
<p>스왑 매수(고정 지급/변동 수취)인 상황에서 변동금리가 기간에 따라 우상향하는 형태라면, 스왑계약의 가치를 평가할 때 스왑계약 초기에 지급받는 변동금리보다 후기에 지급받는 변동금리가 크게 계산되므로, 각 이자지급시기의 NPV는 처음에는 (-)이다가 시간이 지날수록 (+)로 전환되는 구조일 것 입니다. 이 경우, 스왑계약은 시간이 흐르면서 이자지급시기가 지나면, 자연스럽게 계약의 가치가 증가하게 됩니다.</p>
<p>반대로, 변동금리기 우하향한다면 NPV는 (+)에서 (-)로 전환되고, 시간의 흐름에 따라 계약의 가치가 감소하게 됩니다.</p>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled" title="Difference in compounding methods">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Difference in compounding methods
</div>
</div>
<div class="callout-body-container callout-body">
<p>IRS의 swap rate를 valuation할 때, swap rate는 해당 스왑계약의 교환주기에 맞는 compounding method를 사용한다는 것을 유의해야 합니다.</p>
<p>즉, 6개월마다 교환한다면 semi-annually, 3개월마다 교환한다면 querterly, 1개월마다 교환한다면 monthly compounding 방식으로 swap rate를 산출해야합니다.</p>
<p>반면, 할인율로 일반적으로 사용하는 zero rate는 continuous compouding으로 산출하므로, swap rate를 zero rate로 변환할 때 유의해야 합니다.</p>
<p>(Table 7.3 구해보기)</p>
</div>
</div>
</section>
<section id="fixed-for-fixed-currency-swaps" class="level2">
<h2 class="anchored" data-anchor-id="fixed-for-fixed-currency-swaps">7.8 Fixed-For-Fixed Currency Swaps</h2>
<p>또 하나의 유명한 형태의 스왑으로는 고정-고정 통화스왑이 있습니다.</p>
<p>두가지의 다른 통화에 대해, 계약시점과 종료시점에 통화원금을 주고 받고, 계약 중에는 주기적으로 각 통화에 대한 고정금리를 주고 받는 형태입니다.</p>
<p>예를 들어, 달러가 필요한 A기업이 명목금액 100만달러의 5년 만기 고정통화스왑을 매수한다면, 계약시점에 100만달러를 받고 이에 상응하는 원화를 지급한 다음, 상대방에게 고정금리에 대한 달러이자를 계속 지급하다가, 만기에 다시 원금을 주고 받는 계약을 말합니다. 이 때, 원금을 주고 받는데 적용되는 환율은 통상 현재 환율을 사용합니다.</p>
<p>고정통화스왑도 이자율스왑과 마찬가지로 자산이나 부채를 다른 통화의 현금흐름으로 바꾸고 싶거나, 두 가지의 통화에 대한 차입비용에 비교우위가 있는 경우 비교우위 전략을 사용하는 데에 활용됩니다.</p>
</section>
<section id="valuation-of-fixed-for-fixed-currency-swaps" class="level2">
<h2 class="anchored" data-anchor-id="valuation-of-fixed-for-fixed-currency-swaps">7.9~10 Valuation of Fixed-For-Fixed Currency Swaps</h2>
<p>고정통화스왑도 마찬가지로 선도계약을 이용하여 평가합니다.</p>
<ol type="1">
<li><p>먼저, 고정통화스왑의 미래 현금흐름은 고정되어있으므로, 각 이자지급시기 및 만기에 따른 현금흐름을 각 통화별로 구합니다.</p></li>
<li><p>현재 환율을 이용하여 각 이자지급시기별 선도환율을 계산합니다.</p></li>
<li><p>각 이자지급시기별 타방 통화에 대한 현금흐름을 선도환율을 이용하여 평가합니다.</p></li>
<li><p>각 이자지급시기별 순현금흐름을 현재가치로 환산합니다. (계약시작시점이라면, 환율 또는 고정이자율을 NPV=0이 되도록 결정합니다.)</p></li>
</ol>
<p>한편, 고정통화스왑의 각 통화별 미래현금흐름은 각 통화별 채권과 동일합니다. 따라서, 고정통화스왑의 가치를 채권의 가격을 이용하여 표현할 수 있습니다.</p>
<p><span class="math display">\[V_{swap,foregin\;pay}=B_D-S_0B_F\]</span></p>
<div class="callout callout-style-default callout-note callout-titled" title="Another Currency Swaps">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Another Currency Swaps
</div>
</div>
<div class="callout-body-container callout-body">
<p>또다른 통화스왑으로는, Fixed-for-floating Swap, Floating-for-floating Swap이 있습니다.</p>
<p>원금을 처음과 마지막에 주고 받는 방식은 동일하지만, 고정통화스왑과 다르게 어느 일방의 통화 또는 양방의 통화에 적용되는 이자가 변동금리라는 차이점이 있습니다.</p>
<p>이러한 유형의 통화스왑의 현금흐름은, 고정통화스왑+이자율스왑과 동일하기 때문에, 가치평가를 할 때에도 두가지 스왑으로 구분한 다음, 앞서 서술한 선도계약을 이용한 평가방식을 적용하여 각 스왑을 평가하고 더해서 산출할 수 있습니다.</p>
</div>
</div>
</section>
<section id="other-types-of-swaps" class="level2">
<h2 class="anchored" data-anchor-id="other-types-of-swaps">7.11~13 Other Types of Swaps</h2>
<section id="cds-credit-default-swaps" class="level3">
<h3 class="anchored" data-anchor-id="cds-credit-default-swaps">CDS, Credit Default Swaps</h3>
<p>먼저, 앞서 설명하였던 Credit Risk의 관리는 파생상품계약 및 스왑계약에 있어서 매우 중요합니다. CCP를 이용하지 않고 계약 당사자간 청산결제가 이루어지는 경우, 거래상대방의 Default로 인해 예기치 못한 손실이 발생할 수 있기 때문입니다.</p>
<div class="callout callout-style-default callout-caution callout-titled" title="Market Risk vs. Credit Risk">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Market Risk vs.&nbsp;Credit Risk
</div>
</div>
<div class="callout-body-container callout-body">
<p>Market Risk : 파생상품의 기초자산의 가격변동, 이자율의 변동 등으로 인해 손실을 입을 위험</p>
<p>Credit Risk : 거래상대방의 Default 등으로 결제불이행이 발생해 손실을 입을 위험</p>
<p>파생상품계약은 두 가지 위험이 항상 상존하지만, Market Risk는 다른 상품으로 Hedge할 수 있는 반면, Credit Risk는 완전히 없앨 수는 없습니다.</p>
</div>
</div>
<p>이러한 Credit Risk를 Market Risk처럼 관리하고자 만들어진 상품이 CDS입니다. 신용하락 또는 Default를 우려하는 A기업이 이를 Hedge하기 위해 명목금액 100만달러에 5년만기 CDS 매수를 한다면, 5년 뒤에 A기업의 회사채 신용도 하락이 없었다면 A기업은 매도자에게 100만달러<span class="math inline">\(\times\;CDS\;spread\)</span>를 지급하고, 신용도 하락 등으로 회사채 금리가 상승하였다면, 100만달러에 대한 조달비용 상승분을 매도자에게 수취하는 구조입니다.</p>
<p>매수자는 신용하락에 대한 보험을 가지고 이에 대한 대가를 지급하며, Default 상황이 발생하면 매도자가 손실을 보전하는 구조로 마치 보험과 같은 성격을 가지고 있습니다.</p>
</section>
<section id="other-interest-rate-swaps" class="level3">
<h3 class="anchored" data-anchor-id="other-interest-rate-swaps">Other Interest Rate Swaps</h3>
<ol type="1">
<li>Floating-For-Floating IRS : 변동금리 간에 IRS로, 가산금리를 정해서 결정. Basis swaps</li>
<li>Amortizing swap : 스왑의 만기까지 명목금액이 지속 감소</li>
<li>Step-up swap : 스왑의 만기까지 명목금액이 지속 증가</li>
<li>Forward swap : 계약 후 일정시점까지는 이자교환 없음, deferred swaps.</li>
<li>compounding swap : 일방 or 양방의 이자를 누적하여 만기시점에 일시 교환</li>
<li>Accrual swap : 변동금리가 일정 수준 이내일때만 고정금리 지급</li>
</ol>
</section>
<section id="quantos" class="level3">
<h3 class="anchored" data-anchor-id="quantos">Quantos</h3>
<p>통화스왑의 일종이지만, 원금 및 이자교환을 어느 한 통화로만 결제하는 방식의 스왑계약으로, Diff swap이라고도 함.</p>
</section>
<section id="equity-swaps" class="level3">
<h3 class="anchored" data-anchor-id="equity-swaps">Equity Swaps</h3>
<p>총수익스왑(Total Return Swap)의 일종으로, 주식에서 발생하는 자본수익, 배당 등 총수익을 미리 정해둔 고정 or 변동금리와 교환하는 스왑.</p>
</section>
<section id="options" class="level3">
<h3 class="anchored" data-anchor-id="options">Options</h3>
<ol type="1">
<li>Extendable swap : 어느 일방에 스왑의 만기를 연장시킬 수 있는 권리가 부여된 스왑계약.</li>
<li>Puttable swap : 어느 일방에 스왑을 조기종료시킬 수 있는 권리가 부여된 스왑계약.</li>
<li>Swaptions : Options on swaps라고도 하며, 어느 일방에 미래 교환시기에 스왑계약에 따라 정해둔 교환을 실행할지 말지에 대한 권리가 부여된 스왑계약.</li>
</ol>
</section>
<section id="other-swaps" class="level3">
<h3 class="anchored" data-anchor-id="other-swaps">Other Swaps</h3>
<ol type="1">
<li>Comodity swap : 동일한 가격의 만기가 다른 선도계약을 연속적으로 체결하고자 하는 경우, 상품스왑을 이용함.</li>
<li>Volatility swap : 미리 정해둔 기초자산과 변동성에 대해, 교환시기에 해당 변동성<span class="math inline">\(\times\)</span>명목금액과 교환시기에 실현된 변동성(Historical volatility)<span class="math inline">\(\times\)</span>명목금액을 교환하는 스왑계약.</li>
</ol>


</section>
</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2024, Hyeonghwan Kim</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>